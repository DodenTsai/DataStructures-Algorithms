# DFS 与 BFS
## 深度优先搜索
深度优先搜索（DFS）的核心思想，是试图穷举所有的完整路径，其本质是一个栈结构。在深度优先搜索中，往往使用递归来模拟入栈、出栈的逻辑。

二叉树的先序遍历正是深度优先搜索思想的递归实现，可以说深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。
- 函数调用的底层是由栈来实现的，JavaScript 会维护“函数调用栈”。递归函数每调用一次自己，相关调用的上下文就会被`push`进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被`pop`出来。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实
- DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号；如果需要记录下路径，就需要强制使用栈结构

## 广度优先搜索
### 基本概念
与深度优先搜索不同的是，广度优先搜索（BFS）关心的是眼下自己能够直接到达的所有坐标，其动作有点类似于“扫描”。按照这个思路，广度优先搜索每次以“广度”为第一要务、雨露均沾，一层一层地扫描，最后也能够将所有的坐标扫描完全。

在分层遍历的过程中，有两个规律：
- 每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉
- 站在某个确定坐标的位置上，所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们

丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，和队列有着密不可分的关系。

### BFS 的代码实现
```
function BFS(入口坐标) {
  // 初始化队列queue
  const queue = [];
  // 入口坐标首先入队
  queue.push(入口坐标);
  // 队列不为空，说明没有遍历完全
  while (queue.length) {
    // 取出队头元素
    const top = queue[0];
    // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等
    访问 top
    // 注意这里也可以不用 for 循环，视题意而定
    for (检查 top 元素出发能够遍历到的所有元素) {
      queue.push(top能够直接抵达的元素);
    }
    // 访问完毕。将队头元素出队
    queue.shift();
  }
}
```

### 使用 BFS 对二叉树进行层序遍历
```
function BFS(root) {
  // 初始化队列 queue
  const queue = [];
  // 根结点首先入队
  queue.push(root);
  // 队列不为空，说明没有遍历完全
  while (queue.length) {
    // 取出队头元素
    const top = queue[0];
    // 访问 top
    console.log(top.val);
    // 如果左子树存在，左子树入队
    if (top.left) {
      queue.push(top.left);
    }
    // 如果右子树存在，右子树入队
    if (top.right) {
      queue.push(top.right);
    }
    // 访问完毕，队头元素出队
    queue.shift();
  }
}
```

# 递归与回溯思想
## 基本概念
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。

许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。回溯算法的基本思想是从一条路往前走，能进则进，不能进则退回来，换一条路再试。

## 解题模板
### 使用回溯的前提
- 问题中暗示了一个或多个解，并且要求详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯
- 题目经分析后，可以转化为树形逻辑模型求解

### 使用回溯的原因
递归与回溯的过程，本身就是穷举的过程。问题中要求列举每一个解都是基于穷举思想、对搜索树进行恰当地剪枝后得来的。   

这里需要注意到另一种问法：不问解的内容，只问解的个数。这类问题往往不用 DFS 来解，而是用动态规划。

### 使用方法
```
function xxx(入参) {
  前期的变量定义、缓存等准备工作
  // 定义路径栈
  const path = [];
  // 进入 dfs
  dfs(起点);

  // 定义 dfs
  dfs(递归参数) {
    if (到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return;
    }
    // 注意这里也可能不是 for，视题意决定
    for (遍历坑位的可选值) {
      path.push(当前选中值);
      处理坑位本身的相关逻辑
      path.pop();
    }
  }
}
```

## 递归与回溯问题案例
### 全排列问题
LeetCode：[46. 全排列](https://leetcode-cn.com/problems/permutations/)

#### 问题描述
给定一个没有重复数字的序列，返回其所有可能的全排列。
```
示例：   
    输入: [1,2,3]
    输出: [
          [1,2,3],
          [1,3,2],
          [2,1,3],
          [2,3,1],
          [3,1,2],
          [3,2,1],
        ]
```

#### 问题分析
从`n`个不同元素中任取`m（m ≤ n）`个元素，按照一定的顺序排列起来，叫做从`n`个不同元素中取出`m`个元素的一个排列。当`m === n`时所有的排列情况叫全排列。即拿到一个`n`个数的数组作为入参，穷举出这`n`个数的所有排列方式。    

一般来说，遇到“穷举”相关的问题，都尽量使用 DFS，以递归方式来实现。而这个问题的解答思路中也有一个非常关键的特征，即重复。只要分析出重复的逻辑，都需要想到递归；只要想到递归，立刻尝试使用 DFS 思想。

#### 问题实现
```
/**
  * @param {number[]} nums
  * @return {number[][]}
  */
// 入参是一个数组
const permute = function(nums) {
  // 缓存数组的长度
  const len = nums.length;
  // curr 变量用来记录当前的排列内容
  const curr = [];
  // res 用来记录所有的排列顺序
  const res = [];
  // visited 用来避免重复使用同一个数字
  const visited = {};
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs (nth) {
    // 若遍历到了不存在的坑位（第 len + 1 个），则触碰递归边界返回
    if (nth === len) {
      // 此时前 len 个坑位已经填满，将对应的排列记录下来
      res.push(curr.slice()) return;
    }
    // 检查手里剩下的数字有哪些
    for(let i = 0; i < len; i++) {
      // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
      if (!visited[nums[i]]) {
        // 给 nums[i] 打个“已用过”的标
        visited[nums[i]] = 1;
        // 将 nums[i] 推入当前排列
        curr.push(nums[i])
        // 基于这个排列继续往下一个坑走去
        dfs(nth + 1);
        // nums[i] 让出当前坑位
        curr.pop();
        // 下掉“已用过”标识
        visited[nums[i]] = 0;
      }
    }
  } 
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0);
  return res;
};
```

#### 注意事项
- `Map`结构`visited`的使用：每用到一个数字，都要给这个数字打上“已用过”的标，避免它被使用第二次；数字出去时，对应的排列和`visited`状态也需要被及时地更新掉
- 当走到递归边界时，一个完整的排列也到手了；将这个完整排列推入结果数组时，用了`res.push(curr.slice())`而不是简单的`res.push(curr)`。是因为全局只有一个唯一的`curr`，`curr`的值会随着 DFS 的进行而不断被更新。 `slice`方法的作用是帮助拷贝出一个不影响`curr`正本的副本，以防直接修改到`curr`的引用

### 组合问题
LeetCode：[78. 子集](https://leetcode-cn.com/problems/subsets/)

#### 问题描述
给定一组不含重复元素的整数数组`nums`，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。
```
输入：nums = [1, 2, 3]
输出：
    [
     [3],
     [1],
     [2],
     [1,2,3],
     [1,3],
     [2,3],
     [1,2],
     [],
    ]
```

#### 问题分析
这个问题出现了穷举，大概率会用到 DFS。只要用到 DFS，就要想到树形思维方式，进而想到递归式和递归边界的问题。在这个过程中，需要注意的是对递归边界的限制条件的确定。

在这个问题中，每个组合中数字的个数是不确定的，不变的东西变成了可以参与组合的数字，变化的东西则是每个数字在组合中的存在性。因此思路可以调整为，从每一个数字入手，讨论它出现或者不出现的情况。 

从`root`出发，每一个数字对应树的一层，存在或不存在对应树的两个分叉。从第一层到第三层，得到的所有完整路径，就是 3 个数的所有可能的组合形式。  
- 递归式：检查剩下的数字有哪些，选取其中一个填进当前的坑里、或者干脆把这个坑空出来
- 递归边界：组合里数字个数的最大值。拿示例来说，只给了 3 个数，因此组合里数字最多也只有 3 个，超过 3 个则视为触碰递归边界

### 问题实现
```
/**
  * @param {number[]} nums
  * @return {number[][]}
  */
// 入参是一个数组
const subsets = function(nums) {
  // 初始化结果数组
  const res = [];
  // 缓存数组长度
  const len = nums.length;
  // 初始化组合数组
  const subset = [];
  // 进入 dfs
  dfs(0);

  // 定义 dfs 函数，入参是 nums 中的数字索引
  function dfs (index) {
    // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
    res.push(subset.slice());
    // 从当前数字的索引开始，遍历 nums
    for(let i = index; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(nums[i]);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i+1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

### 限定组合问题
LeetCode：[77. 组合](https://leetcode-cn.com/problems/combinations/)

#### 问题描述
给定两个整数`n`和`k`，返回`1 ... n`中所有可能的`k`个数的组合。

```
输入：n = 4，k = 2
输出：
    [
     [2,4],
     [3,4],
     [2,3],
     [1,2],
     [1,3],
     [1,4],
    ]
```

#### 问题分析
这是一个复杂化的组合问题，它追加了一个限定条件，这其实就是“剪枝”的过程。在深度优先搜索中，有时会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”。 

在这个问题中，要做到剪枝，需要分别在组合问题的递归式和递归边界上动手脚：
- 递归式：普通组合问题，每到一个新的坑位处，都需要对组合结果数组进行更新；在这个问题中，当且仅当组合内数字个数为`k`个时，才会对组合结果数组进行更新
- 递归边界：只要组合内数字个数达到了`k`个，就不再继续当前的路径往下遍历，而是直接返回

#### 问题实现
```
/**
  * @param {number} n
  * @param {number} k
  * @return {number[][]}
  */
const combine = function (n, k) {
  // 初始化结果数组
  const res = [];
  // 初始化组合数组
  const subset = [];
  // 进入 dfs，起始数字是 1
  dfs(1);
  // 定义 dfs 函数，入参是当前遍历到的数字
  function dfs (index) {
    if (subset.length === k) {
      res.push(subset.slice());
      return;
    }
    // 从当前数字的值开始，遍历 index - n 之间的所有数字
    for (let i = index; i <= n; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(i);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i+1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

### 岛屿数量问题
LeetCode：[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)
    
#### 问题描述
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。
```
示例 1：
      输入：grid = [
                   ["1","1","1","1","0"],
                   ["1","1","0","1","0"],
                   ["1","1","0","0","0"],
                   ["0","0","0","0","0"]
                  ]
      输出：1
示例 2：
      输入：grid = [
                   ["1","1","0","0","0"],
                   ["1","1","0","0","0"],
                   ["0","0","1","0","0"],
                   ["0","0","0","1","1"]
                  ]
      输出：3
```

#### 问题分析
这个问题中出现的“网格”就是二维数组，“岛屿”和“水”已经抽象为了“1”和“0”的数字。因此这个问题实际要解决的就是：已知一个二维数组，定义“相互连接的1”为一个块（这里的相互连接，意思就是 1 和 1 之间可以不经过 0 就相互抵达），求符合条件的块的数量。另外一说，通过“相互连接”而形成的思路为若当前所在位置是 1，从1出发，可以抵达的所有 1 都和它算作同一个岛屿。看到“所有”，必须想到“枚举”，看到“枚举”，必须回忆起 DFS 和 BFS。

在明确了 DFS 的方向之后，需要解决两个问题。即如何实现对不同岛屿的统计和已经计算过的岛屿如何排除。
- 岛屿的统计：从起点出发，遵循“不撞水面（也就是 0）不回头”的原则，枚举当前可以触及的所有 1。当枚举无法继续进行时，说明当前这座岛屿被遍历完毕，记为一个。也就是说每完成一次 DFS，就累加一个岛屿
- 避免重复计算的方法：每遍历过一个 1，就把它置为 0，后续再次路过时就会自动忽略它

#### 问题实现
```
/**
 * @param {character[][]} grid
 * @return {number}
 */
// 入参是二维数组
const numIslands = function(grid) {
  const moveX = [0, 1, 0, -1];
  const moveY = [1, 0, -1, 0];
  // 处理二维数组的边界情况
  if(!grid || grid.length === 0 || grid[0].length === 0) {
    return 0;
  }  
  // 初始化岛屿数量
  let count = 0;  
  // 缓存二维数组的行数和列数
  let row = grid.length, column = grid[0].length;
  // 以行和列为线索，尝试“逐个”遍历二位数组中的坑位
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < column; j++) {
      if (grid[i][j] === '1') {
        // 每遇到 1，就进入 dfs，探索岛屿边界
        dfs(grid, i, j);
        // 每完成一个 dfs，就累加一个岛屿
        count++;
      }
    }
  }
  return count;

  // 编写探索岛屿边界的逻辑
  function dfs(grid, i, j) {  
    // 如果试图探索的范围已经越界，则 return
    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0'){
      return;  
    }   
    // 遍历过的坑位都置 0，防止反复遍历
    grid[i][j] = ‘0';
    // 遍历完当前的 1，继续去寻找下一个 1
    for(let k = 0; k < 4; k++) {
      dfs(grid, i+moveX[k], j+moveY[k]);
    }
  }
}
```

这个问题的实现中有个技巧就是对`moveX`和`moveY`两个数组的设定：
```
const moveX = [0, 1, 0, -1];
const moveY = [1, 0, -1, 0];
```

借助这两个数组，可以完成对当前格子的“垂直”和“水平”两个方向上的相邻格子的检查：
```
for(let k = 0; k < 4; k++) {
  dfs(grid, i + moveX[k], j + moveY[k]);
}
```
后序遇到强调了“水平”、“垂直”方向上的相邻关系，就可以复用这个套路。

### 扫地机器人
LeetCode：[]()

### 问题描述
房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。扫地机器人提供 4 个API，可以向前进，向左转或者向右转。每次转弯 90 度。当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。请利用提供的 4 个 API 编写让机器人清理整个房间的算法。
```
interface Robot {
  // 若下一个方格为空，则返回 true，并移动至该方格
  // 若下一个方格为障碍物，则返回 false，并停留在原地
  boolean move();

  // 在调用 turnLeft / turnRight 后机器人会停留在原位置
  // 每次转弯 90 度
  void turnLeft();
  void turnRight();

  // 清理所在方格
  void clean();
}
```

示例：
```
输入：
    room = [
            [1, 1, 1, 1, 1, 0, 1, 1],
            [1, 1, 1, 1, 1, 0, 1, 1],
            [1, 0, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 1, 1]
           ],
    row = 1,
    col = 3
```

输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用 4 个给出的 API 解决问题。扫地机器人的初始位置一定是空地；扫地机器人的初始方向向上；所有可抵达的格子都是相连的，亦即所有标记为 1 的格子机器人都可以抵达；可以假定格栅的四周都被墙包围。

#### 问题分析
对于这个问题的场景，最要紧的是从冗长的描述中去提取出确切的算法问题。这个问题涉及到对二维数组网格的枚举，可能与岛屿数量问题的基本思路一致（即将 DFS 作为优先方法来考虑）：
1. 机器人从初始位置出发，检查上下左右四个方向是否有障碍物，进而决定是否进入对应方向的格子完成清扫
2. 因为问题描述强调了“所有可抵达的格子都是相连的，亦即所有标记为 1 的格子机器人都可以抵达”，所以借助 DFS 尝试枚举所有可抵达的格子是完全没有问题的。DFS 的主要递归逻辑其实就是步骤 1
3. 当某一个方向已经“撞到南墙”后，机器人应该逐渐回溯到上一个位置，尝试新的方向
4. 最后，由于递归边界其实就是障碍物/已经清扫过的格子；所以别忘了对已经清扫过的格子做个标记

但是这个问题的复杂之处在于强调了“上下左右”的概念，它要求先旋转、再判断、最后根据判断结果决定是否需要前进。也就是说，不仅需要考虑机器人的前进坐标，还需要考虑机器人的旋转角度。其实无论旋转也好、前进也罢，本质上都是让它“自己动”。大家记住，“自己动”往往和循环有关。

在这个问题中，就可以用循环来实现四个方向的旋转和前进。明确了循环结构的设计，现在继续来分析循环体。

既然问题描述已经把步骤拆成了旋转和前进两步，那么就有必要把旋转角度和前进坐标之间的关系对应起来。假设机器人现在所在的格子坐标是`(i, j)`，它的旋转角度以及对应的前进坐标之间就有以下关系：
```
（定义逻辑）  
// 初始化角度为 0 度  
let dir = 0;   
...   


（判断逻辑）
// 将角度和前进坐标对应起来
switch(dir) {
  // 0 度的前进坐标，是当前坐标向上走一步
  case 0:   
    x = i - 1;
    break;
  // 90度（顺时针）的前进坐标，是当前坐标向右走一步
  case 90: 
    y = j + 1; 
    Break;
  // 180度（顺时针）的前进坐标，是当前坐标向下走一步
  case 180: 
    x = i + 1;
    break;
  // 270度（顺时针）的前进坐标，是当前坐标向左走一步
  case 270: 
    y = j - 1;
    break;
  default:
    break;
}
...

（叠加逻辑）
// 注意这里我给机器人的规则就是每次顺时针转一个方向，所以是 turnRight
robot.turnRight();
// turnRight的同时，dir需要跟着旋转90度  
dir += 90;
// 这里取模是为了保证dir在[0, 360]的范围内变化
dir %= 360;
```

但是这个问题中，题给的四个 API 都不是自己实现的，一旦改了全局的`room`变量，可能会影响到别的 API。保险起见，应该优先考虑不污染`room`变量的实现方法，这里我借助的是`Set`数据结构：
```
（以下是定义逻辑）
//初始化一个 set 结构来存储清扫过的坐标
const boxSet =  new Set();
...


（以下是判断逻辑）
// 标识当前格子的坐标
let box = i + '+' + j;
// 如果已经打扫过，那么跳过
if(boxSet.has(box)) return;
// 打扫当前这个格子
robot.clean();
// 记住这个格子
boxSet.add(box);
```

#### 问题实现
```
/**
 * @param {Robot} robot
 * @return {void}
 */
const cleanRoom = function(robot) {
  // 初始化一个 set 结构来存储清扫过的坐标
  const boxSet =  new Set();
  // 初始化机器人的朝向
  let dir = 0;
  // 进入 dfs
  dfs(robot, boxSet, 0, 0, 0);

  // 定义 dfs  
  function dfs (robot, boxSet, i, j, dir) {
    // 记录当前格子的坐标
    let box = i + '+' + j;
    // 如果已经打扫过，那么跳过
    if (boxSet.has(box)) return;
    // 打扫当前这个格子
    robot.clean();  
    // 记住这个格子
    boxSet.add(box);

    // 四个方向试探
    for (let k = 0; k < 4; k++) {
      // 如果接下来前进的目标方向不是障碍物（也就意味着可以打扫）
      if (robot.move()) {
        // 从当前格子出发，试探上右左下
        let x = i, y = j;
        // 处理角度和坐标的对应关系
        switch (dir) {
          case 0:   
            x = i - 1;
            break;
          case 90: 
            y = j + 1; 
            break;
          case 180: 
            x = i + 1;  
            break;  
          case 270: 
            y = j - 1;
            break;   
          default:
            break;
        }
        dfs(robot, boxSet, x, y, dir);
        // 一个方向的dfs结束了，意味着撞到了南墙，此时我们需要回溯到上一个格子 
        robot.turnLeft();
        robot.turnLeft();
        robot.move();
        robot.turnRight();
        robot.turnRight();
      }
      // 转向 
      robot.turnRight();
      dir += 90;
      dir %= 360;
    }
  }
}
```



---

【 完 】