# 动态规划的基本概念
## 基本概念
分治问题的核心思想是：把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解。

而动态规划的思想和“分治”有点相似。不同之处在于，“分治”思想中，各个子问题之间是独立的：比如说归并排序中，子数组之间的排序并不互相影响。而动态规划划分出的子问题，往往是相互依赖、相互影响的。

在使用动态规划解决问题时，要抓以下两个关键特征：
- 最优子结构：问题的最优解包含着子问题的最优解，不管前面的决策如何，此后的状态必须是基于当前状态的最优决策
- 重叠子问题：在递归的过程中，出现了反复计算的情况

## 分析技巧
动态规划就是一种自底向上的思维方式，但是在解决问题的时候，还是需要通过递归来思考问题的解决方案。

树形思维模型将能够更迅速地定位到状态转移关系，边界条件往往对应的就是已知子问题的解；基于树形思维模型，结合记忆化搜索，最后再将递归转换成迭代，就可以通过动态规划思想来解决问题了。

然后，动态规划思想是比较复杂的，利用递归和记忆化搜索的思想只是帮助简化问题，但它仍存在一些难点：
- 状态转移方程不好确定
- 已知的状态可能不明显
- 递归转换成迭代比较困难

因此，对于动态规划，这里可以选择如下的分析路径：
1. 递归思想明确树形思维模型：找到问题的终点，思考回溯的方式，可以更快速地明确状态间的关系
2. 结合记忆化搜索，明确状态转移方程
3. 递归代码转化为迭代表达

# 动态规划问题案例
## 爬楼梯
LeetCode：[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 问题描述
假设你正在爬楼梯。需要`n`阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```
示例 1：
      输入： 2
      输出： 2
示例 2：
      输入： 3
      输出： 3
```

### 问题分析
这个问题有两个关键的特征，因此可以用动态规划的思想来解决问题：
- 要求给出达成某个目的的解法个数
- 不要求给出每一种解法对应的具体路径

#### 递归思想分析
基于动态规划的思想来解决问题，首先要想到的思维工具就是“倒着分析问题”，其分为两步：
1. 定位到问题的终点
2. 站在终点这个视角，思考后退的可能性

在这个问题中，“问题的终点”指的就是走到第`n`阶楼梯这个目标对应的路径数，把它记为`f(n)`；站在第`n`阶楼梯这个视角，按问题要求，一次只能后退 1 步或者 2 步，因此可以定位到从第`n`阶楼梯只能后退到第`n - 1`或者第`n - 2`阶。

现在把抵达第`n - 1`阶楼梯对应的路径数记为`f(n - 1)`；把抵达第`n - 2`阶楼梯对应的路径数记为`f(n - 2)`，不难得出`f(n) = f(n - 1) + f(n - 2)`。要想求出`f(n)`，必须求出`f(n - 1)`和`f(n - 2)`。

接着站在第`n - 1`阶台阶上，也只能是退到`n - 1 - 1`层台阶或`n - 1 - 2`层台阶上，所以`f(n - 1)`和`f(n - 2)`、`f(n - 3)`间同样具有`f(n - 1) = f(n - 2) + f(n - 3)`的关系。同理，`f(n - 2)`也可以按照同样的规则拆分为`f(n - 2) = f(n - 3) + f(n - 4)`。

随着拆分的进行，一定会有一个时刻，求解到了`f(1)`或`f(2)`。按照问题的规则，第 1 阶楼梯只能走 1 步抵达，第 2 阶楼梯可以走 1 步或者走 2 步抵达，因此不难得出`f(1)`和`f(2)`的值为`f(1) = 1`; `f(2) = 2`。

遇到“树形思维模型”，就要想办法往递归上靠。这个问题明显用到了树形思维模型，有着明确的重复内容，同时有着明确的边界条件，因此不难写出其对应的递归解法代码：
```
/**
* @param {number} n
* @return {number}
*/
const climbStairs = function(n) {
  // 处理递归边界
  if(n === 1) {
    return 1;
  }
  if(n === 2){
    return 2;
  }
  // 递归计算
  return climbStairs(n - 1) + climbStairs(n - 2);
};
```

但是这个解法会导致多个结点被重复计算，造成算法超时的问题。

#### 记忆化搜索来提效
重复计算带来了时间效率上的问题，要想解决这类问题，最直接的思路就是用空间换时间，也就是想办法记住之前已经求解过的结果。这里只需要定义一个数组`const f = []`，每计算出一个`f(n)`的值，都把它塞进`f`数组里。下次要用到这个值的时候，直接取出来就行了：
```
/**
* @param {number} n
* @return {number}
*/
// 定义记忆数组 f
const f = [];
const climbStairs = function(n) {
  if(n === 1) {
    return 1;
  }
  if(n === 2) {
    return 2;
  }
  // 若 f[n] 不存在，则进行计算
  if(f[n]===undefined) {
    f[n] = climbStairs(n - 1) + climbStairs(n - 2);
  }
  // 若 f[n] 已经求解过，直接返回
  return f[n];    
};
```
以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。

#### 记忆化搜索转化为动态规划
记忆化搜索可以理解为优化过后的递归，而递归往往可以基于树形思维模型来解决，是一个明显的自顶向下的过程；而动态规划则刚好相反，是一个自底向上的过程。

### 问题实现
```
/**
* @param {number} n
* @return {number}
*/
const climbStairs = function(n) {
  // 初始化状态数组
  const f = [];
  
  // 初始化已知值
  f[1] = 1;
  f[2] = 2;

  // 动态更新每一层楼梯对应的结果
  for(let i = 3;i <= n;i++){
    f[i] = f[i-2] + f[i-1];
  }
  
  // 返回目标值
  return f[n];
};
```

## 如何优雅地找硬币
LeetCode：[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

### 问题描述
给定不同面额的硬币`coins`和一个总金额`amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回`-1`。你可以认为每种硬币的数量是无限的。
```
示例 1：
      输入：coins = [1, 2, 5]，amount = 11
      输出：3i
示例 2：
      输入：coins = [2]，amount = 3
      输出：-1
示例 3：
      输入：coins = [1]，amount = 0
      输出：0
示例 4：
      输入：coins = [1]，amount = 1
      输出：1
示例 5：
      输入：coins = [1]，amount = 2
      输出：2
```

### 问题分析
这个问题首先要确认状态转移方程，因此需要的是站在`amount`这个组合结果上的回溯方式，即可以把问题转化为从`amount`减到`0`这个问题。

从`amount`总额中减去`coins`中的某一个面额的硬币这个动作，经过重复地往前推到这个拿走的过程，如果用`f(x)`表示每一个`amount`数字对应的最少硬币数，可以得到对应关系：`f(x) = Math.min(f(x - c1) + 1, f(x - c2) + 1, …, f(x - cn) + 1)`。

这个对应关系，就是这个问题的状态转移方程。

既然得出了状态转移方程，接下来就需要思考递归的边界条件。在这个问题中，需要考虑的是硬币总额为`0`的情况，这种情况下对应的硬币个数也会是`0`。即`f[0] = 0`。

### 问题实现
```
const coinChange = function(coins, amount) {
  // 用于保存每个目标总额对应的最小硬币个数
  const f = [];
  // 提前定义已知情况
  f[0] = 0;
  // 遍历 [1, amount] 这个区间的硬币总额
  for(let i = 1; i <= amount; i++) {
    // 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
    f[i] = Infinity;
    // 循环遍历每个可用硬币的面额
    for(let j = 0;j < coins.length; j++) {
      // 若硬币面额小于目标总额，则问题成立
      if(i - coins[j] >= 0) {
        // 状态转移方程
        f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      }
    }
  }

  // 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
  if (f[amount] === Infinity) {
    return -1;
  }
  // 若有解，直接返回解的内容
  return f[amount];
};
```

## 0 - 1 背包模型
LeetCode：[]()

### 问题描述
有`n`件物品，物品体积用一个名为`w`的数组存起来，物品的价值用一个名为`value`的数组存起来；每件物品的体积用`w[i]`来表示，每件物品的价值用`value[i]`来表示。现在有一个容量为`c`的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？每种物品都只有 1 件。

### 问题分析
这个问题中，提到了使背包内的物品总价值最大；遇到求最值的问题，一定要考虑到动态规划的方案。

现在，假设背包已满，容量已经达到了`c`。站在`c`这个容量终点往后退，考虑从中取出一样物品，那么可能被取出的物品就有`i`种可能性。现在尝试表达“取出一件”这个动作对应的变化，用`f(i, c)`来表示前`i`件物品恰好装入容量为`c`的背包中所能获得的最大价值。现在假设试图取出的物品是`i`，那么只有两种可能：
- 第`i`件物品在背包里
- 第`i`件物品不在背包里

如果说本来这个背包中就没有`i`这个东西，那么尝试取之前和尝试取之后，背包中的价值总量是不会发生变化的：`f(i, c) = f(i - 1, c)`；但如果背包中是有`i`的，那么取出这个动作就会带来价值量和体积量的减少：`f(i, c) - value[i] = f(i - 1, c - w[i])`。

把这个减法关系稍微转化一下，变为加法关系：`f(i, c) = f(i - 1, c - w[i]) + value[i]`。

可以看出，想要求出`f(i, c)`，只要定位到正确的`f(i - 1, c)`和`f(i - 1, c-w[i]) + value[i]`的值，并且取出两者中较大的值就可以了。如此，就明确出了这道题的状态转移关系。现在需要思考的是如何把这种关系用代码的形式表达出来。

首先，基于上面的分析抽取出自变量和因变量：自变量是物品的索引（假设为`i`）和当前背包内物品的总体积（假设为`v`），因变量是总价值。这里仍然是用一个数组来记忆不同状态下的总价值，考虑到这道题中存在两个自变量，需要开辟的是一个二维数组。现在利用二维数组来将上述的状态关系编码化：
`dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - w[i]] + c[i])`。

因为动态规划的关键特性就是最优子结构，因此只要能够利用倒推法明确出状态转移方程，就没有必要再去构造一个完整而复杂的树形结构了。

在这个状态转移方程中，变量是`i`和`v`，但本质上来说`v`也是随着`i`的变化而变化的，因此可以在外层遍历`i`、在内层遍历`v`。因此可以编码如下：
```
for (let i = 1; i <= n; i++) {
  for (let v = w[i]; v <= c; v++) {
    dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v -w[i]] + value[i]);
  }
}
```

然而，在计算`dp[i][v]`的时候，只需要计算`dp[i - 1][v]`和`dp[i - 1][v -w[i]]`就可以了。实际上，对于第`i`行的计算来说，只有第`i - 1`行的数据是有意义的，更早的数据它都不关心。也就是说其实根本不需要记录所有的数据，理论上只要保留当前行和上一行的数据就足够了。

在这里，可以用滚动数组概念，将二维数组转变为一维数组。

所谓“滚动数组”，顾名思义，就是让数组“滚动”起来。即固定一块存储空间，滚动更新这块存储空间的内容，确保每个时刻空间内的数据都是当前真正会用到的最新数据，从而达到节约内存的效果，这种手段就叫做滚动数组。

在这里可以只定义一个一维数组，通过倒着遍历`v`的方法来实现数组的滚动更新：
```
for (let i = 1; i <= n; i++) {
  for (let v = c; v >= w[i]; v--) {
    dp[v] = Math.max(dp[v], d[v - w[i]] + value[i]);
  }
}
```

拿第`i - 1`行和第`i`行来举例，首先肯定是用第`i - 1`行的数据把一维数组给填满了；接下来尝试用第`i`行的数据更新它。当数据更新走`dp[i][v]`这里的时候，`dp[i - 1][v]`和`dp[i - 1][v - w[i]]`都是存在的状态（分别对应一维数组中现在的`dp[v]`和`dp[v - w[i]]`的值，完全可以满足计算的需要。当计算出`dp[i][v]`的值以后，`dp[i - 1][v - w[i]]`可能还会在以后的计算中用到，但`dp[i-1][v]`其实已经完全用不到了。此时刚好用`dp[i][v]`去更新了`dp[v]`的值，把用不到的数据给及时地替换掉。

### 问题实现
```
// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组
function knapsack(n, c, w, value) {
  // dp 是动态规划的状态保存数组
  const dp = (new Array(c + 1)).fill(0);
  // res 用来记录所有组合方案中的最大值
  let res = -Infinity;
  for(let i = 1; i <= n;i++) {
    for(let v = c; v >= w[i]; v--) {
      // 写出状态转移方程
      dp[v] = Math.max(dp[v], dp[v - w[i]] + value[i]);
      // 即时更新最大值
      if(dp[v] > res) {
        res = dp[v];
      }
    }
  }
  return res;
}
```

## 最长上升子序列模型
LeetCode：[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### 问题描述
给定一个无序的整数数组，找到其中最长上升子序列的长度。
```
示例：
    输入：[10, 9, 2, 5, 3, 7, 101, 18]
    输出：4
```

### 问题分析
上升子序列指输入序列中的某一段，且其中排在后面的元素总是要大于排在前面的元素的序列。

在这个问题中，需要把握一个关键特征，即“序列”。对于序列类型的问题，背后的思想都是需要关注到序列中元素的索引，尝试去寻找不同索引对应的元素之间的关系，并以索引为线索去构造一维或二维的状态数组。在这里，需要关注的就是“以序列中第`i`个元素为结尾的前`i`个元素的状态”。

用`f(i)`来表示前`i`个元素中最长上升子序列的长度。若想基于`f(i)`求解出`f(i + 1)`，需要关注到的是第`i + 1`个元素和前`i`个元素范围内的最长上升子序列的关系，它们之间的关系有两种可能：
- 若第`i + 1`个元素比前`i`个元素中某一个元素要大，就可以在这个元素所在的上升子序列的末尾追加第`i + 1`个元素，得到一个新的上升子序列
- 若第`i + 1`个元素并不比前`i`个元素中所涵盖的最长上升子序列中的某一个元素大，则维持原状，子序列不延长

重复上面这个“遍历新元素+回头看”的逻辑，直到整个数组被完全遍历，就能拿到以每一个索引位元素为结尾的最长上升子序列的长度值。从这些长度值中筛选出最大值，也就得到了问题的解。

### 问题实现
```
/**
 * @param {number[]} nums
 * @return {number}
 */
// 入参是一个数字序列
const lengthOfLIS = function(nums) {
  // 缓存序列的长度
  const len = nums.length;
  // 处理边界条件
  if (!len) {
    return 0;
  }
  // 初始化数组里面每一个索引位的状态值
  const dp = (new Array(len)).fill(1);
  // 初始化最大上升子序列的长度为1
  let maxLen = 1;
  // 从第2个元素开始，遍历整个数组
  for(let i = 1; i < len; i++) {
    // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列
    for(let j = 0; j < i; j++) {  
      // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态
      if(nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    // 及时更新上升子序列长度的最大值
    if(dp[i] > maxLen) {
      maxLen = dp[i];
    }
  }
  // 遍历完毕，最后到手的就是最大上升子序列的长度
  return maxLen;
};
```

## 最长回文子串问题
LeetCode：[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

### 问题描述
给定一个字符串`s`，找到`s`中最长的回文子串。你可以假设`s`的最大长度为`1000`。
```
示例 1：
      输入: "babad"
      输出: "bab"

示例 2：
      输入: "cbbd"
      输出: "bb"
```

### 问题分析
这个问题中出现了“最长”二字，表明了这是一道“求最值”型问题。看到最值，就要把动态规划调度进可用解题工具里。在这个问题中，较长回文子串中可能包含较短的回文子串（即最优子结构）；若按照暴力解法来做，多次遍历的过程中不可避免地会涉及到对同一个回文子串的重复判断（重叠子问题），因此，这道题用动态规划求解是比较合理的。

原始接收到的是一个字符串序列，符合“序列型”动态规划的特征。大家现在已经知道，对于序列型动态规划，总是需要以它的索引为线索去构造一维或二维的状态数组。对于这道题来说，由于定位任意子串需要的是两个索引，因此状态数组应该是一个二维数组：
```
// 初始化一个二维数组
let dp = [];
const len = s.length
for (let i = 0; i < len; i ++) {
  dp[i] = [];
};
```

由于`i`和`j`分别表示子串的两个端点，只要明确了这两个值，就能间接地求出子串的长度。因此`dp[i][j]`不必额外记录长度这个状态，只需要记录该区间内的字符串是否回文。这里我们把回文记为`1`（或`TRUE`），不回文记为`0`（或`FALSE`）。

按照这个思路走下去，需要关注到的无疑就是字符串的两个端点`s[i]`和`s[j]`。当遍历到一对新的端点的时候，有以下两种可能的状态转移情况：
- `s[i] === s[j]`：只要以`s[i + 1]`和`s[j - 1]`为端点的字符串是回文字符串，那么`dp[i][j] = 1`就成立，否则`dp[i][j] = 0`
- `s[i] !== s[j]`：这种情况下，一定有`dp[i][j] = 0`

到这里，也就明确到了这道题的状态转移方程：
```
if(s[i] === s[j]) {
  dp[i][j] = dp[i + 1][j - 1];  
} else {
  dp[i][j] = 0;
}
```

找出了状态转移方程，现在来找边界值。这里需要注意的是：如果在一个序列中，涉及到了`i`、`j`两个索引，那么一定要关注到`i === j`这种特殊情况。在这个问题中，由于`i === j`时，`dp[i][i]`对应的是一个单独的字母，单独的字母必然回文（长度为`1`），因此`dp[i][i] = 1`就是这个问题的边界值（或者说初始值）。

### 问题实现
```
/**
 * @param {string} s
 * @return {string}
 */
const longestPalindrome = function(s) {
  const dp = [];
  // 缓存字符串长度
  const len = s.length
  // 初始化状态二维数组
  for (let i = 0; i < len; i ++) {
    dp[i] = [];
  };
    
  // 初始化最长回文子串的两个端点值
  let st = 0, end = 0;
  // 初始化最长回文子串的初始值为1
  for(let i = 0; i < len; i++) {
    dp[i][i] = 1;
  }
  // 这里为了降低题目的复杂度，我们预先对悬念比较小的 s[i][i + 1] 也做了处理
  for(let i = 0; i < len - 1; i++){
    if(s[i] === s[i + 1]) {
      dp[i][i + 1] = 1;
      st = i;
      end = i + 1;
    }
  }
    
  // n 代表子串的长度，从 3 开始递增
  for(let n = 3; n <= len; n++) {
    // 下面的两层循环，用来实现状态转移方程
    for(let i = 0; i <= len - n; i++) {
      let j = i + n - 1;
      if (dp[i + 1][j - 1]) {
        if (s[i] === s[j]) {
          // 若定位到更长的回文子串，则更新目标子串端点的索引值
          dp[i][j] = 1;
          st = i;
          end = j;
        }
      }
    }
  }
  // 最后依据端点值把子串截取出来即可
  return s.substring(st,end+1);
}
```

## 粉刷房子
LeetCode：[256. 粉刷房子]()

### 问题描述
假如有一排房子，共`n`个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个`n x 3`的矩阵来表示的。

例如，`costs[0][0]`表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]`表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本；所有花费均为正整数。
```
示例：
    输入：[[17, 2, 17], [16, 16, 5], [14, 3, 19]]
    输出：10
```

### 问题分析
这个问题的特征非常肤浅，从概念的角度来说，动态规划的两个特征全部命中；从技巧的角度来说，“求最值”这个信号也在疯狂暗示用动态规划来解决它。

对于最值型动态规划，最常用的思路仍然是动态规划专题中首推的“倒推”法。结合“倒推”法，可以得出题目对应的状态转移方程是：
```
f[i][x] = Math.min(f[i - 1][x 以外的索引 1 号], f[i - 1][x 以外的索引 2 号]) + costs[i][x];
```

其中`f[i][x]`对应的是当粉刷到第`i`个房子时，使用第`x`（`x = 0`、`1`、`2`）号油漆对应的总花费成本的最小值。

状态的初始值，就是当`i = 0`时对应的三个值：
```
f[0][0] = costs[0][0];
f[0][1] = costs[0][1];
f[0][2] = costs[0][2];
```

`f[0][0]`、`f[0][1]`、`f[0][2]`分别表示当粉刷到第 0 个房子时，对它使用 0 号、1 号、2 号油漆对应的总花费成本。此时由于只粉刷了一个房子，所以总花费成本就等于房子本身的花费成本。

### 问题实现
以下为基础实现本问题：
```
/**
 * @param {number[][]} costs
 * @return {number}
 */
const minCost = function(costs) {
  // 处理边界情况
  if (!costs || !costs.length) return 0;
  // 缓存房子的个数
  const len = costs.length;
  // 初始化状态数组（二维）
  const f = new Array(len);
  for (let i = 0; i < len; i++) {
    f[i] = new Array(3);
  }
  // 初始化状态值
  f[0][0] = costs[0][0];
  f[0][1] = costs[0][1];
  f[0][2] = costs[0][2];   
  // 开始更新刷到每一个房子时的状态值
  for (let i = 1; i < len; i++) {
    // 更新刷到当前房子时，给当前房子选用第 0 种油漆对应的最小总价
    f[i][0] = Math.min(f[i - 1][1], f[i - 1][2]) + costs[i][0];
    // 更新刷到当前房子时，给当前房子选用第1种油漆对应的最小总价
    f[i][1] = Math.min(f[i - 1][2], f[i - 1][0]) + costs[i][1];
    // 更新刷到当前房子时，给当前房子选用第 2 种油漆对应的最小总价
    f[i][2] = Math.min(f[i - 1][1], f[i - 1][0]) + costs[i][2];
  }
  // 返回刷到最后一个房子时，所有可能出现的总价中的最小值
  return Math.min(f[len - 1][0], f[len - 1][1], f[len - 1][2]);
};
```

当然，这个问题也可以用“滚动数组”来优化算法：
```
/**
 * @param {number[][]} costs
 * @return {number}
 */
const minCost = function(costs) {
  // 处理边界情况
  if (!costs || !costs.length) return 0;
  // 缓存房子的个数
  const len = costs.length;
  // 开始更新状态
  for (let i = 1; i < len; i++) {  
    // now 表示粉刷到当前房子时对应的价格状态
    const now = costs[i];
    // prev 表示粉刷到上一个房子时的价格状态
    const prev = costs[i - 1];  
    // 更新当前状态下，刷三种油漆对应的三种最优价格
    now[0] += Math.min(prev[1], prev[2]);  
    now[1] += Math.min(prev[0], prev[2]); 
    now[2] += Math.min(prev[1], prev[0]);
  }
  // 返回粉刷到最后一个房子时，总价格的最小值
  return Math.min(costs[len - 1][0], costs[len - 1][1], costs[len - 1][2]);
};
```

---

【 完 】