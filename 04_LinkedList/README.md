# 链表
## 基本概念
链表和数组相似，都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。

链表中的结点，允许散落在内存空间的各个角落里。对它来说，元素和元素之间毫无内存上的关联。因此，在链表的各个结点之间，需要为它们创建关联指针。链表中的每一个结点都包含了数据域和指针域两个部分。

JavaScript 中的链表，是以嵌套的形式实现的，形如：

```
{
  // 数据域
  val: 1,
  // 指针域，指向下一个结点
  next: {
    val: 2,
    next: …
  }
}
```

## 链表的操作
### 创建链表结点
创建链表结点，需要一个构造函数。在使用构造函数创建结点时，传入`val`（数据域对应的值内容）、指定`next`（下一个链表结点）即可。

```
function ListNode(val) {
  this.val = val;
  this.next = null;
}

const node = new ListNode(1);
node.next = new ListNode(2);
```

### 添加链表结点
链表的结点间关系是通过`next`指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕`next`指针做文章。

- 直接在链表的尾部添加结点，直接将原尾部结点的`next`指针指向添加的结点即可。
- 如果在任意两个结点之间插入一个新的结点，需要变更前驱结点和后继结点的`next`指针。

```
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3);
// 把 node3 的 next 指针指向 node2（即 node1.next）
node3.next = node1.next;
// 把 node1 的 next 指针指向 node3
node1.next = node3;
```

### 删除链表结点
链表结点的删除标准为在链表的遍历过程中，无法再遍历到某个结点的存在。因此可以直接让它的前驱结点的`next`跳过它指向它的`next`指针指向的结点。当结点成为一个完全无法访问的结点之后，JavaScript 的垃圾回收机制将会将其回收。

在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。

```
// 利用 node1 可以定位到 node3
const target = node1.next;
node1.next = target.next;
```

## 链表与数组
假设数组的长度是`n`，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度`n`的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是`O(n)`。

相对于数组来说，链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。在链表中，添加和删除操作的复杂度是固定的。不管链表里面的结点个数`n`有多大，只要明确了要插入或删除的目标位置，那么只需要改变目标结点及其前驱或后继结点的指针指向。因此链表的增删操作的复杂度是常数级别的复杂度，用大`O`表示法表示为`O(1)`。

但是链表也有一个弊端，即试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。随着链表长度的增加，搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大`O`表示法表示为`O(n)`。

而在数组中可以直接访问索引，这个操作的复杂度会被降级为常数级别`O(1)`。

结合上述分析，不难得出结论：链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。

# 链表的问题案例
链表相关的问题，一般分为三类，即链表的处理（合并、删除等）、链表的反转及其衍生和链表成环及其衍生。

## 链表的合并
LeetCode：[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 问题描述
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。
``` 
输入：1 -> 2 -> 4, 1 -> 3 -> 4
输出：1 -> 1 -> 2 -> 3 -> 4 -> 4
```

### 问题分析
处理链表的本质，是处理链表结点之间的指针关系。两个链表如果想要合并为一个链表，恰当地补齐双方之间结点`next`指针的指向关系，就能达到目的。同时还要考虑`l1`和`l2`两个链表长度不等的情况：若其中一个链表已经完全被串进新链表里了，而另一个链表还有剩余结点，考虑到该链表本身就是有序的，可以直接把它整个拼到目标链表的尾部。

### 问题实现
```
/**
  * @param {ListNode} l1
  * @param {ListNode} l2
  * @return {ListNode}
  */
const mergeTwoLists = function(l1, l2) {
  // 定义头结点，确保链表可以被访问到
  let head = new ListNode();
  // cur 这里就是咱们那根“针”
  let cur = head;
  // “针”开始在 l1 和 l2 间穿梭了
  while(l1 && l2) {
    // 如果 l1 的结点值较小
    if(l1.val <= l2.val) {
      // 先串起 l1 的结点
      cur.next = l1;
      // l1 指针向前一步
      l1 = l1.next;
    } else {
      // l2 较小时，串起 l2 结点
      cur.next = l2;
      // l2 向前一步
      l2 = l2.next;
    }
    // “针”在串起一个结点后，也会往前一步
    cur = cur.next;
  }
  // 处理链表不等长的情况
  cur.next = l1 !== null ? l1 : l2;
  // 返回起始结点
  return head.next;
};
```

## 链表结点的删除
LeetCode：[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

### 问题描述
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```
示例 1：
    输入：1 -> 1 -> 2
    输出：1 -> 2
示例 2：
    输入：1 -> 1 -> 2 -> 3 -> 3
    输出：1 -> 2 -> 3
```

### 问题分析
链表的删除是一个基础且关键的操作，将需要删除的目标结点的前驱结点`next`指针往后指一格。另外需要判断两个元素是否重复，由于此处是已排序的链表，直接判断前后两个元素值是否相等即可。

### 问题实现
```
/**
  * @param {ListNode} head
  * @return {ListNode}
  */
const deleteDuplicates = function(head) {
  // 设定 cur 指针，初始位置为链表第一个结点
  let cur = head;
  // 遍历链表
  while(cur != null && cur.next != null) {
    // 若当前结点和它后面一个结点值相等（重复）
    if(cur.val === cur.next.val) {
      // 删除靠后的那个结点（去重）
      cur.next = cur.next.next;
    } else {
      // 若不重复，继续遍历
      cur = cur.next;
    }
  }
  return head;
};
```

## dummy 结点问题（链表结点的删除问题延伸）
LeetCode：[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

### 问题描述
给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中没有重复出现的数字。
```
示例 1：
    输入：1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5
    输出：1 -> 2 -> 5
示例 2：
    输入：1 -> 1 -> 1 -> 2 -> 3
    输出：2 -> 3
```

### 问题分析
要删除链表中某一个目标结点时，必须知道它的前驱结点，但这个问题是需要将前驱或后继一起删除掉，这时就可以用一个`dummy`结点来解决这个问题。

`dummy`结点是一个人为制造出来的第一个结点的前驱结点，这样链表中所有的结点都能确保有一个前驱结点，也就都能够用同样的逻辑来处理了。`dummy`结点能够降低链表处理过程的复杂度，处理链表时，不设`dummy`结点思路可能会打不开；设了`dummy`结点的话，就算不一定用得上，也不会出错。

### 问题实现
```
/**
  * @param {ListNode} head
  * @return {ListNode}
  */
const deleteDuplicates = function(head) {
  // 极端情况：0 个或 1 个结点，则不会重复，直接返回
  if(!head || !head.next) {
    return head;
  }
  // dummy 登场
  let dummy = new ListNode();
  // dummy 永远指向头结点
  dummy.next = head;
  // cur 从 dummy 开始遍历
  let cur = dummy;
  // 当 cur 的后面有至少两个结点时
  while(cur.next && cur.next.next) {
    // 对 cur 后面的两个结点进行比较
    if(cur.next.val === cur.next.next.val) {
      // 若值重复，则记下这个值
      let val = cur.next.val;
      // 反复地排查后面的元素是否存在多次重复该值的情况
      while(cur.next && cur.next.val===val) {
        // 若有，则删除
        cur.next = cur.next.next;
      }
    } else {
      // 若不重复，则正常遍历
      cur = cur.next;
    }
  }
  // 返回链表的起始结点
  return dummy.next;
};
```
