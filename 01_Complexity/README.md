# 基本概念
## 原因
如果通过机器上运行代码来统计算法的性能，有很大的局限性，容易受到测试环境、数据规模的影响：
- 测试环境影响：不同系统、处理器的机器得出的测试结果不相同
- 数据本身、规模影响：不同数据、不同长度的数据的出的测试结果不相同

## 复杂度表示
从 CPU 的角度看，每段代码就是读写或操作数据。因此可以粗略的把每一次执行的时间都看作一致，写作`unit_time`。 以下代码可以看作总共执行了`(2n + n) * unit_time`：
```
function cal(n) {
  let sum = 0;            // 1 unit_time
  let i = 0;              // 1 unit_time
  for(; i <= n; i++) {    // n unit_time
    sum += i;             // n unit_time
  }
  return sum；
}
```

因此，可以用大 O 表示法写作：`T(n) = O(2n + 2)`。因为复杂度通常用来表示算法执行性能的趋势，因此会对其进行简化：
- 用常量`1`取代运行时间中的所有加法运算
- 在修改后的运行函数中，只保留最高阶级
- 如果最高存在且不为`1`，则去除与该项目相乘的常数

经过简化，上述代码的复杂度可以表示为：`T(n) = O(n)`。但上面的复杂度推导仅仅只表现了算法执行的时间消耗，因此也叫做时间复杂度（渐进时间复杂度）。

# 常见的复杂度表示
## 时间复杂度
- 常数：`O(1)`
- 对数：`O(log(n))`
- 线性：`O(n)`
- 线性和对数乘积：`O(nlog(n))`
- 平方：`O(n ^ 2)`
- 指数：`O(2 ^ n)`

时间复杂度受到数据本身的影响，还分为：
- 最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
- 最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度
- 平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量

## 空间复杂度
时间复杂度表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度表示算法的存储空间与数据规模之间的增长关系。

如下代码的空间复杂度为`O(1+n) = O(n)`，即数组`a`和变量`i`所占用的内存空间：
```
function fun(n) {
  let a = [];
  for (let i = 0; i < n; i++) {
    a.push(i);
  }
  return a;
}
```

---

【 完 】